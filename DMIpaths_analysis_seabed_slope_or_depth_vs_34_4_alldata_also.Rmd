---
title: "Seabed Slope/Depth Correlation vs β — split & ALL-data"
output: 
  pdf_document: 
    fig_height: 7
---

 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

### Load packages & IO

```{r load}
rm(list = ls())
setwd("~/WORKSHOP/ESBJERG2/PUBLICATION/")
suppressPackageStartupMessages({
  library(dplyr)
  library(readr)
  library(ggplot2)
  library(viridis)
  library(stringr)
  library(tidyr)
})

# Paths (keep your originals here if different)
path_input_csv <- "~/WORKSHOP/LOS/OUTPUT/seabed_slope_and_band_depths_ESBJERG3.csv"
path_input_csv <- "DATA/seabed_slope_and_band_depths_ESBJERG3.csv"
path_goodies   <- "/home/pth/WORKSHOP/ESBJERG2/PUBLICATION/OUTPUT/the_goodies.rds"
path_best      <- "/home/pth/WORKSHOP/ESBJERG2/PUBLICATION/OUTPUT/the_best.rds"

# Ensure figure dirs
fig_dir <- "FIGURES/BOXPLOTS"
dir.create(fig_dir, recursive = TRUE, showWarnings = FALSE)

# Data
df_input <- read_csv(path_input_csv, show_col_types = FALSE)

goodies <- readRDS(path_goodies)
best    <- readRDS(path_best)

# Normalize filenames & drop overlap (why: avoid double counting) 
df_input$filename <- trimws(tolower(df_input$filename))
goodies$filename  <- trimws(tolower(goodies$filename))
best$filename     <- trimws(tolower(best$filename))

best_ids <- best$filename
#goodies_exclusive <- goodies[!goodies$filename %in% best_ids, , drop = FALSE]

# Drop overlap cleanly
goodies_exclusive <- dplyr::anti_join(goodies, dplyr::select(best, filename), by = "filename")

# Build ALL pool (one row per filename)
all_beta <- dplyr::bind_rows(
  dplyr::select(goodies_exclusive, filename, beta1),
  dplyr::select(best,            filename, beta1)
) |> dplyr::distinct(filename, .keep_all = TRUE)

```

### Select a single covariate
```{r choose-column}
# Choose one: "slope_median" OR "depth_band_median_m"
column_to_use <- "slope_median"   # "depth_band_median_m"  # set to "slope_median" if needed
stopifnot(column_to_use %in% names(df_input))
```

### Scan radius combos; compute t‑tests for split + ALL

```{r loop}
results_stat <- tibble()
results_nonstat <- tibble()
results_all <- tibble()

plot_data_split <- list()   # for Stationary/Non‑stationary boxplots
plot_data_all   <- list()   # for ALL single‑panel boxplots

radius_combos <- df_input %>%
  select(inner_radius_km, outer_radius_km) %>%
  distinct() %>%
  filter(outer_radius_km > inner_radius_km)

for (i in seq_len(nrow(radius_combos))) {
  inner <- radius_combos$inner_radius_km[i]
  outer <- radius_combos$outer_radius_km[i]

  df_radius <- df_input %>% filter(inner_radius_km == inner, outer_radius_km == outer)

  merged_stat    <- inner_join(df_radius, goodies_exclusive %>% select(filename, beta1), by = "filename")
  merged_nonstat <- inner_join(df_radius, best %>% select(filename, beta1), by = "filename")
  merged_all     <- inner_join(df_radius, all_beta, by = "filename")

  for (case in list(
    list(dat = merged_stat, out = "stat", label = "Stationary"),
    list(dat = merged_nonstat, out = "nonstat", label = "Non-stationary")
  )) {
    m <- case$dat
    if (!all(c(column_to_use, "beta1") %in% names(m))) next
    x <- m[[column_to_use]]; y <- m$beta1
    if (length(x) < 4 || all(is.na(x))) next

    med <- median(x, na.rm = TRUE)
    if (grepl("slope", column_to_use, ignore.case = TRUE)) {
      grp <- ifelse(x < med, "gentle", "steep")
      g1 <- "gentle"; g2 <- "steep"
    } else if (grepl("depth", column_to_use, ignore.case = TRUE)) {
      grp <- ifelse(x < med, "deep", "shallow")
      g1 <- "deep"; g2 <- "shallow"
    } else {
      grp <- ifelse(x < med, "low", "high"); g1 <- "low"; g2 <- "high"
    }

    # Guard: both groups need >=2
    ok <- sum(grp == g1, na.rm = TRUE) >= 2 && sum(grp == g2, na.rm = TRUE) >= 2
    if (!ok) next

    ttest <- try(t.test(y[grp == g1], y[grp == g2]), silent = TRUE)
    if (inherits(ttest, "try-error")) next

    row <- tibble(
      column = column_to_use,
      inner_radius_km = inner,
      outer_radius_km = outer,
      beta_group1_mean = mean(y[grp == g1], na.rm = TRUE),
      beta_group2_mean = mean(y[grp == g2], na.rm = TRUE),
      delta_beta = mean(y[grp == g2], na.rm = TRUE) - mean(y[grp == g1], na.rm = TRUE),
      t_p_value = ttest$p.value,
      group1 = g1,
      group2 = g2,
      type = case$label
    )

    if (case$out == "stat") results_stat <- bind_rows(results_stat, row) else results_nonstat <- bind_rows(results_nonstat, row)

    m$group <- grp
    m$inner_radius_km <- inner
    m$outer_radius_km <- outer
    m$column <- column_to_use
    m$type <- case$label
    plot_data_split[[length(plot_data_split) + 1]] <- m
  }

  # ALL data (no facet; single p)
  m_all <- merged_all
  if (all(c(column_to_use, "beta1") %in% names(m_all))) {
    x <- m_all[[column_to_use]]; y <- m_all$beta1
    if (length(x) >= 4 && !all(is.na(x))) {
      med <- median(x, na.rm = TRUE)
      if (grepl("slope", column_to_use, ignore.case = TRUE)) {
        grp <- ifelse(x < med, "gentle", "steep")
        g1 <- "gentle"; g2 <- "steep"
      } else if (grepl("depth", column_to_use, ignore.case = TRUE)) {
        grp <- ifelse(x < med, "deep", "shallow")
        g1 <- "deep"; g2 <- "shallow"
      } else { grp <- ifelse(x < med, "low", "high"); g1 <- "low"; g2 <- "high" }

      ok <- sum(grp == g1, na.rm = TRUE) >= 2 && sum(grp == g2, na.rm = TRUE) >= 2
      if (ok) {
        ttest <- try(t.test(y[grp == g1], y[grp == g2]), silent = TRUE)
        if (!inherits(ttest, "try-error")) {
          results_all <- bind_rows(results_all, tibble(
            column = column_to_use,
            inner_radius_km = inner,
            outer_radius_km = outer,
            beta_group1_mean = mean(y[grp == g1], na.rm = TRUE),
            beta_group2_mean = mean(y[grp == g2], na.rm = TRUE),
            delta_beta = mean(y[grp == g2], na.rm = TRUE) - mean(y[grp == g1], na.rm = TRUE),
            t_p_value = ttest$p.value,
            group1 = g1,
            group2 = g2,
            type = "All"
          ))

          m_all$group <- grp
          m_all$inner_radius_km <- inner
          m_all$outer_radius_km <- outer
          m_all$column <- column_to_use
          plot_data_all[[length(plot_data_all) + 1]] <- m_all
        }
      }
    }
  }
}
saveRDS(df_input,'OUTPUT/betas_depths_slopes.rds')
```

### Two‑panel boxplots (split)

```{r split-boxplots}
boxplot_data <- bind_rows(plot_data_split)
if (nrow(boxplot_data) > 0) {
  boxplot_data$type <- factor(boxplot_data$type, levels = c("Stationary", "Non-stationary"))

  for (combo in unique(paste(boxplot_data$inner_radius_km, boxplot_data$outer_radius_km, sep = "_"))) {
    parts <- strsplit(combo, "_")[[1]]
    inner <- parts[1]; outer <- parts[2]

    subset_data <- boxplot_data %>% filter(inner_radius_km == inner, outer_radius_km == outer)
    if (nrow(subset_data) < 4) next

    p_stat <- results_stat %>% filter(inner_radius_km == as.numeric(inner), outer_radius_km == as.numeric(outer), column == column_to_use) %>% pull(t_p_value)
    p_non  <- results_nonstat %>% filter(inner_radius_km == as.numeric(inner), outer_radius_km == as.numeric(outer), column == column_to_use) %>% pull(t_p_value)

    label_data <- tibble(type = c("Stationary", "Non-stationary"), p_value = c(p_stat, p_non), label = sprintf("p = %.4f", c(p_stat, p_non)))
    y_max <- quantile(subset_data$beta1, 0.99, na.rm = TRUE)

    p <- ggplot(subset_data, aes(x = group, y = beta1, fill = group)) +
      geom_boxplot(outlier.shape = 21, outlier.size = 2, outlier.fill = "white", color = "black", width = 0.6) +
      facet_wrap(~type, ncol = 2, scales = "fixed") +
      geom_text(data = label_data, aes(x = 1.5, y = y_max, label = label), inherit.aes = FALSE, size = 5, hjust = 0.5, vjust = -1) +
      scale_fill_manual(values = c("gentle" = "#90ee90", "shallow" = "#90ee90", "steep" = "#f08080", "deep" = "#f08080")) +
      labs(title = bquote(beta ~ " by median split on" ~ .(column_to_use) ~ "(" ~ .(inner) ~ "to" ~ .(outer) ~ " km)"), x = NULL, y = expression(beta)) +
      theme_minimal(base_size = 14) +
      theme(strip.text = element_text(size = 16, face = "bold"), axis.text = element_text(size = 12), axis.title = element_text(size = 14), panel.border = element_rect(colour = "black", fill = NA, linewidth = 1), legend.position = "none", plot.margin = margin(t = 12, r = 10, b = 10, l = 10))

    ggsave(sprintf("%s/boxplot_SPLIT_%s_r%sto%s.png", fig_dir, column_to_use, inner, outer), p, width = 8, height = 5, dpi = 300)
  }
}
```

### Single‑panel boxplots (ALL data)

```{r all-boxplots}
boxplot_all <- bind_rows(plot_data_all)
if (nrow(boxplot_all) > 0) {
  for (combo in unique(paste(boxplot_all$inner_radius_km, boxplot_all$outer_radius_km, sep = "_"))) {
    parts <- strsplit(combo, "_")[[1]]
    inner <- parts[1]; outer <- parts[2]

    sub_all <- boxplot_all %>% filter(inner_radius_km == inner, outer_radius_km == outer)
    if (nrow(sub_all) < 4) next

    p_all <- results_all %>% filter(inner_radius_km == as.numeric(inner), outer_radius_km == as.numeric(outer), column == column_to_use) %>% pull(t_p_value)
    y_max <- quantile(sub_all$beta1, 0.99, na.rm = TRUE)
    label_df <- tibble(x = 1.5, y = y_max, lab = sprintf("p = %.4f", p_all))

    p <- ggplot(sub_all, aes(x = group, y = beta1, fill = group)) +
      geom_boxplot(outlier.shape = 21, outlier.size = 2, outlier.fill = "white", color = "black", width = 0.6) +
      geom_text(data = label_df, aes(x = x, y = y, label = lab), inherit.aes = FALSE, size = 5, hjust = 0.5, vjust = -1) +
      scale_fill_manual(values = c("gentle" = "#90ee90", "shallow" = "#90ee90", "steep" = "#f08080", "deep" = "#f08080")) +
      labs(title = bquote("ALL data:" ~ beta ~ " by median split on" ~ .(column_to_use) ~ "(" ~ .(inner) ~ "to" ~ .(outer) ~ " km)"), x = NULL, y = expression(beta)) +
      theme_minimal(base_size = 14) +
      theme(strip.text = element_text(size = 16, face = "bold"), axis.text = element_text(size = 12), axis.title = element_text(size = 14), panel.border = element_rect(colour = "black", fill = NA, linewidth = 1), legend.position = "none", plot.margin = margin(t = 12, r = 10, b = 10, l = 10))

    ggsave(sprintf("%s/boxplot_ALL_%s_r%sto%s.png", fig_dir, column_to_use, inner, outer), p, width = 6.5, height = 4.5, dpi = 300)
  }
}
```

### Heatmap of log10(p) — split (two panels)

```{r heatmap-split}
if (nrow(results_stat) > 0 && nrow(results_nonstat) > 0) {
  res_split <- bind_rows(results_stat, results_nonstat) %>% mutate(log_p = log10(pmax(t_p_value, 1e-12))) %>% mutate(fade = t_p_value > 0.05)
  for (col in unique(res_split$column)) {
    plot_data <- res_split %>% filter(column == col) %>% mutate(inner_radius_km = factor(inner_radius_km), outer_radius_km = factor(outer_radius_km), alpha = ifelse(fade, 0.3, 1.0))

    x_levels <- levels(plot_data$outer_radius_km)
    y_levels <- levels(plot_data$inner_radius_km)
    x_breaks <- x_levels[seq(1, length(x_levels), by = 2)]
    y_breaks <- y_levels[seq(1, length(y_levels), by = 2)]

    png(sprintf("%s/median_split_log_p_heatmap_SPLIT_%s.png", fig_dir, col), width = 1600, height = 800, res = 150)
    print(
      ggplot(plot_data, aes(x = outer_radius_km, y = inner_radius_km, fill = log_p, alpha = alpha)) +
        geom_tile(color = "grey90") +
        facet_wrap(~type, ncol = 2) +
        scale_fill_viridis_c(option = "inferno", name = "log10(p-value)", limits = c(-4, 0), breaks = c(-4, -3, -2, -1, 0)) +
        scale_alpha_identity() +
        scale_x_discrete(breaks = x_breaks) +
        scale_y_discrete(breaks = y_breaks) +
        labs(title = paste("Median Split t-test p-values for", col, "vs beta"), x = "Outer radius (km)", y = "Inner radius (km)") +
        theme_minimal(base_size = 14) +
        theme(strip.text = element_text(size = 14, face = "bold"), axis.text.x = element_text(angle = 45, hjust = 1))
    )
    dev.off()
  }
}
```

# depth or slope as heatmap colours
```{r}
for (col in unique(res_split$column)) {
  val_col <- col  # e.g. "depth_band_median_m" or "slope_median"

  # Median across files within each (inner, outer) window.
  # If you already have one row per window, this just returns that value.
  source_values <- df_input %>%
    dplyr::group_by(inner_radius_km, outer_radius_km) %>%
    dplyr::summarise(value = median(.data[[val_col]], na.rm = TRUE), .groups = "drop")

  plot_data <- res_split %>%
    dplyr::filter(column == col) %>%
    dplyr::left_join(source_values, by = c("inner_radius_km", "outer_radius_km")) %>%
    dplyr::mutate(
      inner_radius_km = factor(inner_radius_km),
      outer_radius_km = factor(outer_radius_km),
      alpha = ifelse(t_p_value > 0.05, 0.3, 1.0)
    )

  x_levels <- levels(plot_data$outer_radius_km)
  y_levels <- levels(plot_data$inner_radius_km)
  x_breaks <- x_levels[seq(1, length(x_levels), by = 2)]
  y_breaks <- y_levels[seq(1, length(y_levels), by = 2)]

  png(sprintf("%s/median_%s_heatmap_SPLIT.png", fig_dir, col), width = 1600, height = 800, res = 150)
  print(
    ggplot(plot_data, aes(x = outer_radius_km, y = inner_radius_km,
                          fill = value, alpha = alpha)) +
      geom_tile(color = "grey90") +
#      geom_tile(alpha = 1.0) + # uncomment to shoow all cells
      facet_wrap(~type, ncol = 2) +
      scale_fill_viridis_c(name = ifelse(col == "depth_band_median_m", "Median depth (m)", "Median slope")) +
      scale_alpha_identity() +
      scale_x_discrete(breaks = x_breaks) +
      scale_y_discrete(breaks = y_breaks) +
      labs(title = paste("Median", col, "by spatial window"),
           x = "Outer radius (km)", y = "Inner radius (km)") +
      theme_minimal(base_size = 14) +
      theme(strip.text = element_text(size = 14, face = "bold"),
            axis.text.x = element_text(angle = 45, hjust = 1))
  )
  dev.off()
}

```


### Heatmap of log10(p) — ALL (single panel)

```{r heatmap-all}
if (nrow(results_all) > 0) {
  res_all <- results_all %>% mutate(log_p = log10(pmax(t_p_value, 1e-12)), fade = t_p_value > 0.05)
  for (col in unique(res_all$column)) {
    plot_data <- res_all %>% filter(column == col) %>% mutate(inner_radius_km = factor(inner_radius_km), outer_radius_km = factor(outer_radius_km), alpha = ifelse(fade, 0.3, 1.0))

    x_levels <- levels(plot_data$outer_radius_km)
    y_levels <- levels(plot_data$inner_radius_km)
    x_breaks <- x_levels[seq(1, length(x_levels), by = 2)]
    y_breaks <- y_levels[seq(1, length(y_levels), by = 2)]

    png(sprintf("%s/median_split_log_p_heatmap_ALL_%s.png", fig_dir, col), width = 1200, height = 800, res = 150)
    print(
      ggplot(plot_data, aes(x = outer_radius_km, y = inner_radius_km, fill = log_p, alpha = alpha)) +
        geom_tile(color = "grey90") +
        scale_fill_viridis_c(option = "inferno", name = "log10(p-value)", limits = c(-4, 0), breaks = c(-4, -3, -2, -1, 0)) +
        scale_alpha_identity() +
        scale_x_discrete(breaks = x_breaks) +
        scale_y_discrete(breaks = y_breaks) +
        labs(title = paste("ALL data: Median Split t-test p-values for", col, "vs beta"), x = "Outer radius (km)", y = "Inner radius (km)") +
        theme_minimal(base_size = 14) +
        theme(axis.text.x = element_text(angle = 45, hjust = 1))
    )
    dev.off()
  }
}
```

# regression of beta against slope (or depth)
```{r}


# Prepare empty tibble to accumulate regression stats
regression_results <- tibble()

radius_combos <- df_input %>%
  select(inner_radius_km, outer_radius_km) %>%
  distinct() %>%
  filter(outer_radius_km > inner_radius_km)

for (i in seq_len(nrow(radius_combos))) {
  inner <- radius_combos$inner_radius_km[i]
  outer <- radius_combos$outer_radius_km[i]
  
  df_radius <- df_input %>%
    filter(inner_radius_km == inner, outer_radius_km == outer)
  
  # Merge with ALL-data pool for consistent β values (as in your file)
  merged_all <- inner_join(df_radius, all_beta, by = "filename")
  
  # Choose covariate (depth or slope)
  column_to_use <- "slope_median" # OR "depth_band_median_m"
  column_to_use <- "depth_band_median_m" # OR "depth_band_median_m"
  
  # Only proceed if at least 4 valid (non-missing) values
  x <- merged_all[[column_to_use]]
  y <- merged_all$beta1
  if (length(x) < 4 || all(is.na(x))) next
  
  dat <- na.omit(data.frame(beta = y, covar = x))
  
  # Fit linear regression: beta ~ covar
  lmfit <- lm(beta ~ covar, data = dat)
  s_lm <- summary(lmfit)
  
  regression_results <- bind_rows(
    regression_results,
    tibble(
      inner_radius_km = inner,
      outer_radius_km = outer,
      covariate = column_to_use,
      estimate = s_lm$coefficients["covar", "Estimate"],
      p_value = s_lm$coefficients["covar", "Pr(>|t|)"],
      r_squared = s_lm$r.squared,
      n = nrow(dat)
    )
  )
}


```

```{r}
# You can then visualize p_value, r_squared, or estimate by (inner_radius_km, outer_radius_km)
# using ggplot2 heatmap, similarly to how you did for t-test p-values
library(ggplot2)

# Suppose regression_results is your tibble from previous code
pp <- ggplot(regression_results, aes(x = outer_radius_km, y = inner_radius_km, fill = estimate)) +
  geom_tile(color = "grey70") +
  scale_fill_viridis_c(name = "Slope Estimate") +
  labs(
    x = "Outer radius (km)",
    y = "Inner radius (km)",
    title = "β ~ slope: Effect size by spatial window"
  ) +
  theme_minimal(base_size = 14)
print(pp)
png(paste0("FIGURES/BOXPLOTS/heatmap_regression_",column_to_use,".png"))
print(pp)
dev.off()
#
# Suppose regression_results is your tibble from previous code
pp <- ggplot(regression_results, aes(x = outer_radius_km, y = inner_radius_km, fill = -log10(p_value))) +
  geom_tile(color = "grey70") +
  scale_fill_viridis_c(name = "R² Estimate") +
  labs(
    x = "Outer radius (km)",
    y = "Inner radius (km)",
    title = "β ~ slope: Effect size by spatial window"
  ) +
  theme_minimal(base_size = 14)
print(pp)
png(paste0("FIGURES/BOXPLOTS/heatmap_Rsquared_",column_to_use,".png"))
print(pp)
dev.off()
# Suppose regression_results is your tibble from previous code
pp <- ggplot(regression_results, aes(x = outer_radius_km, y = inner_radius_km, fill = r_squared)) +
  geom_tile(color = "grey70") +
  scale_fill_viridis_c(name = "–log₁₀(p-value) Estimate") +
  labs(
    x = "Outer radius (km)",
    y = "Inner radius (km)",
    title = "β ~ slope: Effect size by spatial window"
  ) +
  theme_minimal(base_size = 14)
print(pp)
png(paste0("FIGURES/BOXPLOTS/heatmap_pvalue_",column_to_use,".png"))
print(pp)
dev.off()
```


